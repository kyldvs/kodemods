/*
 *  Copyright (c) 2015-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

require('es6-promise').polyfill();

var child_process = require('child_process');
var clc = require('cli-color');
var dir = require('node-dir');
var fs = require('fs');
var path = require('path');

var availableCpus = require('os').cpus().length - 1;

var log = {
  ok: function ok(msg, verbose) {
    verbose >= 2 && console.log(clc.white.bgGreen(' OKK '), msg);
  },
  nochange: function nochange(msg, verbose) {
    verbose >= 1 && console.log(clc.white.bgYellow(' NOC '), msg);
  },
  skip: function skip(msg, verbose) {
    verbose >= 1 && console.log(clc.white.bgYellow(' SKIP'), msg);
  },
  error: function error(msg, verbose) {
    verbose >= 0 && console.log(clc.white.bgRedBright(' ERR '), msg);
  }
};

function showFileStats(fileStats) {
  console.log('Results:', clc.red(fileStats.error + ' errors'), clc.yellow(fileStats.nochange + ' unmodifed'), clc.yellow(fileStats.skip + ' skipped'), clc.green(fileStats.ok + ' ok'));
}

function showStats(stats) {
  var names = _Object$keys(stats).sort();
  if (names.length) {
    console.log(clc.blue('Stats:'));
  }
  names.forEach(function (name) {
    return console.log(name + ':', stats[name]);
  });
}

function getAllFiles(paths, filter) {
  return _Promise.all(paths.map(function (file) {
    return new _Promise(function (resolve, reject) {
      fs.lstat(file, function (err, stat) {
        if (err) {
          console.log('Skipping path "%s" which does not exist.', file);
          resolve();
          return;
        }

        if (stat.isDirectory()) {
          dir.files(file, function (err, list) {
            return resolve(list ? list.filter(filter) : []);
          });
        } else {
          resolve([file]);
        }
      });
    });
  })).then(function (files) {
    var _ref;

    return (_ref = []).concat.apply(_ref, _toConsumableArray(files));
  });
}

function run(transformFile, paths, options) {
  var cpus = options.cpus ? Math.min(availableCpus, options.cpus) : availableCpus;
  var extensions = options.extensions && options.extensions.split(',').map(function (ext) {
    return '.' + ext;
  });
  var fileChunks = [];
  var fileCounters = { error: 0, ok: 0, nochange: 0, skip: 0 };
  var statsCounter = {};
  var startTime = process.hrtime();

  if (!fs.existsSync(transformFile)) {
    console.log(clc.whiteBright.bgRed('ERROR') + ' Transform file %s does not exist', transformFile);
    return;
  }

  return getAllFiles(paths, function (name) {
    return !extensions || extensions.indexOf(path.extname(name)) != -1;
  }).then(function (files) {
    if (files.length === 0) {
      console.log('No files selected, nothing to do.');
      return;
    }

    var processes = Math.min(files.length, cpus);
    var chunkSize = Math.ceil(files.length / processes);
    for (var i = 0, l = files.length; i < l; i += chunkSize) {
      fileChunks.push(files.slice(i, i + chunkSize));
    }

    console.log('Processing %d files...', files.length);
    if (!options.runInBand) {
      console.log('Spawning %d workers with %d files each...', fileChunks.length, fileChunks[0].length);
    }
    if (options.dry) {
      console.log(clc.green('Running in dry mode, no files will be written!'));
    }

    return fileChunks.map(function (files) {
      var args = [transformFile, options.babel ? 'babel' : 'no-babel'];
      var child = options.runInBand ? require('./Worker')(args) : child_process.fork(require.resolve('./Worker'), args);
      child.send({ files: files, options: options });
      child.on('message', function (message) {
        switch (message.action) {
          case 'status':
            fileCounters[message.status] += 1;
            log[message.status](message.msg, options.verbose);
            break;
          case 'update':
            if (!statsCounter[message.name]) {
              statsCounter[message.name] = 0;
            }
            statsCounter[message.name] += message.quantity;
            break;
        }
      });
      return new _Promise(function (resolve) {
        return child.on('disconnect', resolve);
      });
    });
  }).then(function (pendingWorkers) {
    return _Promise.all(pendingWorkers).then(function () {
      var endTime = process.hrtime(startTime);
      console.log('All done.');
      showFileStats(fileCounters);
      showStats(statsCounter);
      console.log('Time elapsed: %d.%d seconds', endTime[0], (endTime[1] / 1000000).toFixed(0));
      return fileCounters;
    });
  });
}

exports.run = run;